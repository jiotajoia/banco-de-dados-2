-- QUESTÃO 01(A)
CREATE OR REPLACE FUNCTION FUNC_CADASTRAR_COMBO()
RETURNS TRIGGER AS $$
BEGIN
    IF EXISTS (SELECT * FROM COMBO WHERE COD_PROD_COMBO = NEW.COD_PROD) THEN
        RAISE EXCEPTION 'O Produto inserido já é um combo. Não pode fazer parte de outro combo.';
    END IF;

    RETURN NEW;
END;
$$
LANGUAGE plpgsql;

CREATE TRIGGER TG_CADASTRAR_COMBO
BEFORE INSERT ON COMBO
FOR EACH ROW
EXECUTE FUNCTION FUNC_CADASTRAR_COMBO();


--QUESTÃO 01 (B)
CREATE OR REPLACE FUNCTION FUNC_VERIFICA_VENDEDOR()
RETURNS TRIGGER AS $$
DECLARE
    CODLOJA_DO_VENDEDOR INT;
    CODLOJA_DO_ITEM INT;
BEGIN
    SELECT COD_LOJA INTO CODLOJA_DO_VENDEDOR 
    FROM VENDA 
    NATURAL JOIN VENDEDOR 
    WHERE VENDA.COD_VENDA = NEW.COD_VENDA;

    SELECT COD_LOJA INTO CODLOJA_DO_ITEM 
    FROM ESTOQUE 
    WHERE ESTOQUE.COD_ESTOQUE = NEW.COD_ESTOQUE;

    IF CODLOJA_DO_VENDEDOR != CODLOJA_DO_ITEM THEN
        RAISE EXCEPTION 'O Vendedor não pode vender produtos de outra loja';
    END IF;

    RETURN NEW;
END;
$$
LANGUAGE plpgsql;

CREATE TRIGGER TG_VERIFICA_VENDEDOR
BEFORE INSERT ON ITEM_VENDA
FOR EACH ROW
EXECUTE FUNCTION FUNC_VERIFICA_VENDEDOR();

-- QUESTÃO 01 (C)

CREATE OR REPLACE FUNCTION FUNC_VERIFICA_ESTOQUE()
RETURNS TRIGGER AS $$
DECLARE
    REG RECORD;
BEGIN
    -- Loop para verificar o estoque
    FOR REG IN (SELECT COMBO.QUANT, ESTOQUE.QUANT_ESTOQUE 
                FROM COMBO 
                NATURAL JOIN PRODUTO 
                NATURAL JOIN ESTOQUE 
                WHERE COMBO.QUANT = NEW.COD_PROD) 
    LOOP
        -- Verificação de estoque suficiente
        IF REG.QUANT_ESTOQUE < REG.QUANT THEN
            RAISE EXCEPTION 'Estoque insuficiente para o produto %', NEW.COD_PROD;
        END IF;
    END LOOP;

    RETURN NEW; -- Continua com a operação (INSERT, UPDATE, etc.)
END;
$$
LANGUAGE plpgsql;

CREATE TRIGGER TG_VERIFICA_ESTOQUE
BEFORE INSERT OR UPDATE ON ESTOQUE
FOR EACH ROW
EXECUTE FUNCTION FUNC_VERIFICA_ESTOQUE();

-- QUESTÃO 02
CREATE OR REPLACE FUNCTION REALIZA_VENDA(CV INT, NP VARCHAR(50), NC VARCHAR(50), NV VARCHAR(50), QV INT)
RETURNS VOID
AS $$
DECLARE 
    CE INT; -- CÓDIGO DO ESTOQUE
    VU REAL; -- VALOR UNITÁRIO DO PRODUTO
    VTI REAL; -- VALOR TOTAL DO ITEM
    QE INT; -- QUANTIDADE EM ESTOQUE
BEGIN

    SELECT COD_ESTOQUE INTO CE FROM ESTOQUE NATURAL JOIN PRODUTO WHERE NOME_PROD ILIKE NP;
    SELECT VALOR_UNITARIO INTO VU FROM PRODUTO WHERE NOME_PROD ILIKE NP;
    VTI := VU * QV;
    SELECT QUANT_ESTOQUE INTO QE FROM ESTOQUE NATURAL JOIN PRODUTO WHERE NOME_PROD ILIKE NP;

    IF (QV > QE) THEN
        RAISE EXCEPTION 'Não há estoque suficiente para essa quantidade vendida !!';
    END IF;

    IF EXISTS (SELECT * FROM ITEM_VENDA WHERE COD_ESTOQUE = CE AND COD_VENDA = CV) THEN
        UPDATE ITEM_VENDA 
        SET QUANT_VENDIDA = QUANT_VENDIDA + QV, 
            VALOR_TOTAL_ITEM = QUANT_VENDIDA * VU 
        WHERE COD_ESTOQUE = CE AND COD_VENDA = CV;
    ELSE
        INSERT INTO ITEM_VENDA (COD_VENDA, COD_ESTOQUE, QUANT_VENDIDA, VALOR_TOTAL_ITEM) 
        VALUES (CV, CE, QV, VTI);
    END IF;

    UPDATE ESTOQUE 
    SET QUANT_ESTOQUE = QUANT_ESTOQUE - QV 
    WHERE COD_ESTOQUE = CE;

END;
$$
LANGUAGE plpgsql;

-- QUESTÃO 03
CREATE OR REPLACE FUNCTION CALCULA_COMISSAO(NOME VARCHAR(50), DT_INI DATE, DT_FIM DATE)
RETURNS REAL
AS $$
DECLARE 
    COD INT;
    COMISSAO REAL;
    T_VENDAS REAL;
BEGIN

    SELECT COD_VENDEDOR INTO COD FROM VENDEDOR WHERE NOME_VENDEDOR ILIKE NOME;

    SELECT SUM(VALOR_TOTAL) INTO T_VENDAS 
    FROM VENDA 
    WHERE DT_VENDA BETWEEN DT_INI AND DT_FIM AND COD_VENDEDOR = COD;

    COMISSAO := COALESCE(T_VENDAS, 0) * 0.05;

    RETURN COMISSAO;

END;
$$
LANGUAGE plpgsql;