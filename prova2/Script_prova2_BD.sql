-- QUESTÃO 01(A)
CREATE TRIGGER TG_CADASTRAR_COMBO
BEFORE INSERT ON COMBO
FOR EACH ROW
EXECUTE PROCEDURE FUNC_CADASTRAR_COMBO;

CREATE OR REPLACE FUNCTION FUNC_CADASTRAR_COMBO
RETURNS TRIGGERS AS $$
DECLARE 
BEGIN

IF EXISTS (SELECT * FROM COMBO WHERE COD_PROD_COMBO = NEW.COD_PROD ) THEN
 RAISE EXCEPTION 'O Produto inserido já é um combo. Não pode fazer parte de outro combo.'
END IF;

RETURN NEW
END;
$$
LANGUAGE 'plpgsql'


--QUESTÃO 01 (B)
CREATE TRIGGER TG_VERIFICA_VENDEDOR
BEFORE INSERT ON ITEM_VENDA
FOR EACH ROW
EXECUTE PROCEDURE FUNC_VERIFICA_VENDEDOR;

CREATE OR REPLACE FUNCTION FUNC_VERIFICA_VENDEDOR
RETURNS TRIGGERS AS $$
DECLARE 
CODLOJA_DO_VENDENDOR INT;
CODLOJA_DO_ITEM INT;
BEGIN

SELECT COD_LOJA INTO CODLOJA_DO_VENDENDOR FROM ITEM_VENDA NATURAL JOIN VENDA NATURAL JOIN VENDEDOR;
SELECT COD_LOJA INTO CODLOJA_DO_ITEM FROM ITEM_VENDA NATURAL JOIN ESTOQUE;

IF (CODLOJA_DO_VENDEDOR != CODLOJA_DO_ITEM) THEN
	RAISE EXCEPTION 'O Vendedor não pode vender produtos de outra loja';
END IF;

RETURN NEW
END;
$$
LANGUAGE 'plpgsql'


-- QUESTÃO 01 (C)

CREATE TRIGGER TG_VERIFICA_ESTOQUE
BEFORE INSERT OR UPDATE ON ESTOQUE
FOR EACH ROW
EXECUTE PROCEDURE FUNC_VERIFICA_ESTOQUE;

CREATE OR REPLACE FUNCTION FUNC_VERIFICA_ESTOQUE
RETURNS TRIGGERS AS $$
DECLARE 
BEGIN

FOR REG IN (SELECT COMBO.QUANT, ESTOQUE.QUANT_ESTOQUE FROM COMBO NATURAL JOIN PRODUTO NATURAL JOIN ESTOQUE WHERE COMBO.QUANT = NEW.COD_PROD) LOOP
	IF 
END LOOP


RETURN NEW
END;
$$
LANGUAGE 'plpgsql'


-- QUESTÃO 02
CREATE OR REPLACE FUNCTION REALIZA_VENDA (CV INT, NP VARCHAR(50), NC VARCHAR(50), NV VARCHAR(50), QV INT)
RETURNS VOID
AS $$
DECLARE 
CE INT; --CÓDIGO DO ESTOQUE
VU REAL; -- VALOR UNITÁRIO DO PRODUTO
VTI REAL; -- VALOR TOTAL DO ITEM
QE INT; --quantidade em estoque
BEGIN

SELECT COD_ESTOQUE INTO CE FROM ESTOQUE NATURAL JOIN PRODUTO WHERE NOME_PROD ILIKE NP;
SELECT VALOR_UNITARIO INTO VU FROM PRODUTO WHERE NOME_PROD ILIKE NP;
VTI := VU * QV;
SELECT QUANT_ESTOQUE INTO QE FROM ESTOQUE NATURAL JOIN PRODUTO WHERE NOME_PROD ILIKE NP;

IF (QV > QE) THEN
	RAISE EXCEPTION 'Não há estoque suficiente para essa quantidade vendida !!';
END IF;

IF EXISTS (SELECT * FROM INTEM_VENDA WHERE COD_ESTOQUE = CE AND COD_VENDA = CV) THEN
	UPDATE ITEM_VENDA SET QUANT_VENDIDA = QUANT_VENDIDA + QV WHERE COD_ESTOQUE = CE AND COD_VENDA = CV;
	UPDATE ITEM_VENDA SET VALOR_TOTAL_ITEM = QUANT_VENDIDA * VU WHERE COD_ESTOQUE = CE AND COD_VENDA = CV;
	UPDATE ESTOQUE SET QUANT_ESTOQUE = QUANT_ESTOQUE - QV WHERE COD_ESTOQUE = CE;
ELSE
	INSERT INTO ITEM_VENDA VALUES (CV, CE, QV, VTI);
	UPDATE ESTOQUE SET QUANT_ESTOQUE = QUANT_ESTOQUE - QV WHERE COD_ESTOQUE = CE;
END IF;

END;
$$
LANGUAGE 'plpgsql'


-- QUESTÃO 03
CREATE OR REPLACE FUNCTION CALCULA_COMISSAO (NOME VARCHAR(50), DT_INI DATE, DT_FIM DATE)
RETURNS REAL
AS $$
DECLARE 
COD INT;
COMISSAO REAL;
T_VENDAS REAL;
BEGIN

SELECT COD_VENDEDOR INTO COD FROM VENDEDOR WHERE NOME_VENDEDOR ILIKE NOME;

CREATE OR REPLACE VIEW VISAO_COMISSAO AS
SELECT COD_VENDEDOR, SUM(VALOR_TOTAL) TOTAL_VENDAS FROM VENDA WHERE (DT_VENDA BETWEEN DT_INI AND DT_FIM) AND (COD_VENDEDOR = COD) GROUP BY COD_VENDEDOR; 

SELECT TOTAL_VENDAS INTO T_VENDAS FROM VISAO_COMISSAO;

COMISSAO := T_VENDAS * 0.05;

RETURN COMISSAO;

END;
$$
LANGUAGE 'plpgsql'